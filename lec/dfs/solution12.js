function solution(number, range) {
  let answer = [];
  let dy = Array.from(Array(34), () => Array(34).fill(0));
  function DFS(n, r) {
    // 메모이제이션을 활용하여 효율적으로 계산가능하다.
    // 값이 클 경우, 엄청난 가지를 뻗어서 전부 계산 해야한다.
    // 그러나, 이미 계산된 조합이 어떠한 배열에 저장되어 있을경우 바로 뽑아서 그 수를 return 하고 종료되면 가지수를 줄일수있다.
    // 이를 위해 아래의 조건문을 설정해두었다.
    if (dy[n][r] > 0) return dy[n][r];

    if (r === 0 || n === r) {
      return 1;
    } else {
      // nCr 이 5C3 이라고 생각할때,
      // 1~5 까지의 숫자에서 3가지를 뽑아서 생기는 경우의 수를 이야기한다.
      // 만약 5를 기준으로 할때는, 자신을 포함해서 3가지를 뽑는경우의 수와 자신을 제외한 경우의 수를 합한 경우와 같다.
      // 이때, 자신을 포함한 경우의 수를 생각하면 자신은 fix 로 박혀있고 나머지 수들(1~4) 중 2가지를 뽑는 경우의 수와 같다.
      // 자신을 제외한 경우의 수를 생각하면 나머지수들(1~4) 에서 3가지의 경우의 수를 뽑는 수와같다.
      // 이를 더하면 5C3 의 값과 동일하다.
      // 그러므로 아래와 같은 식을 설정해두었다.
      return (dy[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r));
    }
  }
  answer = DFS(number, range);
  return answer;
}
console.log(solution(5, 3));
